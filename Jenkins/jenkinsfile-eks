pipeline {
    agent any

    environment {
        AWS_CREDENTIALS_ID = 'aws-creds'
        CLUSTER_NAME = 'app-clus'
        REGION = 'us-west-2'
    }

    stages {
        stage('Check for Existing EKS Cluster') {
            steps {
                script {
                    echo "üîç Checking if EKS cluster '${CLUSTER_NAME}' already exists..."
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                        def clusterStatus = sh(
                            script: """
                                aws eks describe-cluster \
                                    --name ${CLUSTER_NAME} \
                                    --region ${REGION} \
                                    --query 'cluster.status' \
                                    --output text || echo "NOTFOUND"
                            """,
                            returnStdout: true
                        ).trim()

                        if (clusterStatus == "ACTIVE" || clusterStatus == "CREATING") {
                            echo "‚úÖ Cluster '${CLUSTER_NAME}' already exists with status: ${clusterStatus}"
                            currentBuild.result = 'SUCCESS'
                            return
                        } else {
                            echo "üöÄ Cluster not found. Proceeding to creation..."
                        }
                    }
                }
            }
        }

        stage('Create EKS Cluster') {
            when {
                expression {
                    currentBuild.result != 'SUCCESS'
                }
            }
            steps {
                script {
                    withAWS(credentials: "${AWS_CREDENTIALS_ID}", region: "${REGION}") {
                        echo "üöÄ Creating new EKS cluster..."
                        sh """
                            set -e
                            eksctl create cluster \
                                --name ${CLUSTER_NAME} \
                                --version 1.30 \
                                --region ${REGION} \
                                --nodegroup-name stand-work \
                                --node-type t3.medium \
                                --nodes 2 \
                                --nodes-min 2 \
                                --nodes-max 3 \
                                --managed
                        """
                    }
                }
            }
        }

        stage('Wait for Node Readiness') {
            steps {
                script {
                    echo "‚è≥ Waiting for EKS nodes to become ready..."
                    timeout(time: 10, unit: 'MINUTES') {
                        waitUntil {
                            def readyNodes = sh(
                                script: "kubectl get nodes --no-headers | grep 'Ready' | wc -l",
                                returnStdout: true
                            ).trim().toInteger()
                            echo "Nodes Ready: ${readyNodes}"
                            return readyNodes > 0
                        }
                    }
                    echo "‚úÖ EKS nodes are ready."
                }
            }
        }

        stage('Install ArgoCD') {
            steps {
                script {
                    echo "üöÄ Installing ArgoCD using Helm..."
                    sh """
                        kubectl create namespace argocd || true
                        helm repo add argo https://argoproj.github.io/argo-helm
                        helm repo update
                        helm install argocd argo/argo-cd \
                            --namespace argocd \
                            --set server.service.type=ClusterIP \
                            --set installCRDs=true
                    """
                }
            }
        }

        stage('Apply ArgoCD Application') {
            steps {
                script {
                    echo "üöÄ Applying ArgoCD Application manifest..."
                    sh """
                        kubectl apply -f ArgoCD-config/argo-app.yaml -n argocd
                    """
                }
            }
        }

        stage('Create DB Credentials Secret') {
            steps {
                script {
                    echo "üîê Creating Kubernetes secret for database credentials..."

                    withCredentials([
                        string(credentialsId: 'db-host', variable: 'DB_HOST'),
                        string(credentialsId: 'db-user', variable: 'DB_USER'),
                        string(credentialsId: 'db-pass', variable: 'DB_PASS'),
                        string(credentialsId: 'db-name', variable: 'DB_NAME')
                    ]) {
                        sh """
                            kubectl create secret generic db-credentials \
                              --from-literal=DB_HOST="${DB_HOST}" \
                              --from-literal=DB_USER="${DB_USER}" \
                              --from-literal=DB_PASS="${DB_PASS}" \
                              --from-literal=DB_NAME="${DB_NAME}" \
                              -n default || echo "‚ö†Ô∏è Secret already exists, skipping creation."
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo '‚úÖ EKS cluster creation, ArgoCD installation, and application deployment completed (or already existed).'
        }
        failure {
            echo '‚ùå EKS cluster creation or ArgoCD installation job failed.'
        }
    }
}
