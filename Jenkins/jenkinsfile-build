pipeline {
    agent any

    environment {
        FRONTEND_IMAGE_NAME = 'shashank9928/linkproj-fe'
        BACKEND_IMAGE_NAME = 'shashank9928/linkproj-be'
        DOCKER_CREDENTIALS_ID = 'dock-creds'
        GRAFANA_PASSWORD_CRED_ID   = 'grafana-admin-pass'
        FRONTEND_DEPLOYMENT_FILE = 'k8s/manifests/frontend-deployment.yaml'
        BACKEND_DEPLOYMENT_FILE = 'k8s/manifests/backend-deployment.yaml'
        FRONTEND_DIR = 'frontend'
        BACKEND_DIR = 'backend'
        CLUSTER_NAME = 'app-clus'
        REGION = 'us-west-2'
    }

    stages {
        stage('Wait for EKS Cluster Readiness') {
            steps {
                script {
                    echo "üîç Checking if EKS cluster '${CLUSTER_NAME}' is ACTIVE..."

                    withAWS(credentials: 'aws-creds', region: "${REGION}") {
                        timeout(time: 15, unit: 'MINUTES') {
                            waitUntil {
                                def status = sh(
                                     script: """
                                        aws eks describe-cluster \
                                            --name ${CLUSTER_NAME} \
                                            --region ${REGION} \
                                            --query 'cluster.status' \
                                            --output text
                                    """,
                                    returnStdout: true
                                ).trim()
                                echo "EKS Cluster status: ${status}"
                                return status == "ACTIVE"
                            }
                       }
                    }
                }
            }
        }

        stage('Update kubeconfig') {
            steps {
                script {
                    echo "üîÑ Updating kubeconfig for EKS cluster '${CLUSTER_NAME}'..."

                    withAWS(credentials: 'aws-creds', region: "${REGION}") {
                        sh """
                            aws eks update-kubeconfig \
                                --name ${CLUSTER_NAME} \
                                --region ${REGION} \
                                --alias ${CLUSTER_NAME}
                        """
                        echo "‚úÖ kubeconfig updated successfully."
                    }

                    // Verification step
                    echo "üîç Verifying kubeconfig update..."
                    def contextCheck = sh(
                        script: """
                            kubectl config current-context | grep ${CLUSTER_NAME}
                        """,
                        returnStatus: true
                    )

                    def nodeCheck = sh(
                        script: """
                            kubectl get nodes --context=${CLUSTER_NAME}
                        """,
                        returnStatus: true
                    )

                    if (contextCheck != 0 || nodeCheck != 0) {
                        error("‚ùå Failed to update kubeconfig or connect to the cluster. Please check your configuration.")
                    } else {
                        echo "‚úÖ kubeconfig verification successful. CLUSTER IS REACHABLE."
                    }
                }
            }
        }

        stage('Checkout Source') {
            steps {
                checkout scm
            }
        }

        stage('Install Node.js and npm if Missing') {
            steps {
                script {
                    def npmInstalled = sh(script: 'npm -v', returnStatus: true) == 0
                    if (!npmInstalled) {
                        sh '''
                            curl -fsSL https://deb.nodesource.com/setup_16.x | sudo -E bash -
                            apt install -y nodejs
                        '''
                    }
                }
            }
        }

        stage('Build Frontend') {
            steps {
                dir("${FRONTEND_DIR}") {
                    sh 'npm install'
                    sh 'npm run build'
                }
            }
        }

        stage('Build Backend') {
            steps {
                dir("${BACKEND_DIR}") {
                    sh 'npm install'
                }
            }
        }

        stage('Build & Push Docker Images') {
            steps {
                script {
                    def buildId = "${BUILD_NUMBER}"
                    docker.build("${FRONTEND_IMAGE_NAME}:${buildId}", "-f ${FRONTEND_DIR}/Dockerfile ./${FRONTEND_DIR}")
                    docker.build("${BACKEND_IMAGE_NAME}:${buildId}", "-f ${BACKEND_DIR}/Dockerfile ./${BACKEND_DIR}")

                    docker.withRegistry('https://index.docker.io/v1/', "${DOCKER_CREDENTIALS_ID}") {
                        docker.image("${FRONTEND_IMAGE_NAME}:${buildId}").push()
                        docker.image("${BACKEND_IMAGE_NAME}:${buildId}").push()
                    }
                }
            }
        }

        stage('Update Kubernetes Deployment Manifests') {
            steps {
                script {
                    def buildId = "${BUILD_NUMBER}"
                    def frontendDockerImage = "${FRONTEND_IMAGE_NAME}:${buildId}"
                    def backendDockerImage = "${BACKEND_IMAGE_NAME}:${buildId}"

                    withCredentials([usernamePassword(credentialsId: 'git-creds', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
                        sh """
                            sed -i "s|image: .*linkproj-fe:.*|image: ${frontendDockerImage}|" ${FRONTEND_DEPLOYMENT_FILE}
                            sed -i "s|image: .*linkproj-be:.*|image: ${backendDockerImage}|" ${BACKEND_DEPLOYMENT_FILE}

                            git config user.email "jenkins@mail.com"
                            git config user.name "Jenkins CI"
                            git add ${FRONTEND_DEPLOYMENT_FILE} ${BACKEND_DEPLOYMENT_FILE}
                            git commit -m "Update image tags to build ${buildId}"
                            git push https://${GIT_USERNAME}:${GIT_PASSWORD}@github.com/shashank6613/My-Kubernetes-Project.git HEAD:master
                        """
                    }
                }
            }
        }

        stage('Install Prometheus Monitoring Stack') {
            steps {
                script {
                    echo "üöÄ Installing Prometheus monitoring via Helm..."
                    sh """
                        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                        helm repo update
                        helm install prometheus prometheus-community/kube-prometheus-stack \
                            --namespace monitoring --create-namespace
                    """
                    echo "‚è≥ Waiting for Grafana pod to be running..."
                    timeout(time: 5, unit: 'MINUTES') {
                        waitUntil {
                            sh(script: "kubectl get pods -n monitoring -l app.kubernetes.io/name=grafana --field-selector=status.phase=Running | grep grafana", returnStatus: true) == 0
                        }
                    }
                    echo "‚úÖ Grafana is now running."
                }
            }
        }

        stage('Configure Grafana Admin Password') {
            steps {
                withCredentials([string(credentialsId: "${GRAFANA_PASSWORD_CRED_ID}", variable: 'GRAFANA_PASSWORD')]) {
                    echo "üîê Creating Grafana admin password secret from Jenkins credentials..."
                    sh """
                        kubectl create secret generic grafana-admin-password \
                          --from-literal=admin-password=\"${GRAFANA_PASSWORD}\" \
                          -n monitoring
                    """
                }
            }
        }

        stage('Install Ingress Controller') {
            steps {
                script {
                    echo "üöÄ Installing NGINX Ingress Controller via Helm..."
                    sh """
                        helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
                        helm repo update
                        helm install ingress-nginx ingress-nginx/ingress-nginx \
                            --namespace ingress-nginx --create-namespace \
                            --set controller.publishService.enabled=true
                    """
                    echo "‚è≥ Waiting for NGINX Ingress Controller to be ready..."
                    timeout(time: 5, unit: 'MINUTES') {
                        waitUntil {
                            sh(script: "kubectl get pods -n ingress-nginx -l app.kubernetes.io/component=controller --field-selector=status.phase=Running | grep ingress-nginx-controller", returnStatus: true) == 0
                        }
                    }
                    echo "‚úÖ Ingress Controller is now running."
                }
            }
        }
        stage('Deploy Unified Ingress') {
            steps {
                script {
                    echo "üöÄ Deploying unified ingress for ArgoCD and Prometheus..."
                    sh """
                        kubectl apply -f k8s/ingress/stack-ingress.yaml
                    """
                }
            }
        }
    }

    post {
        success {
            echo "‚úÖ EKS cluster exists and manifests updated in Git. ArgoCD will handle deployment."
        }
        failure {
            echo "‚ùå Pipeline failed. Cleaning up Docker images..."
            script {
                def buildId = "${BUILD_NUMBER}"
                sh """
                    docker rmi ${FRONTEND_IMAGE_NAME}:${buildId} || true
                    docker rmi ${BACKEND_IMAGE_NAME}:${buildId} || true
                """
            }
        }
    }
}
